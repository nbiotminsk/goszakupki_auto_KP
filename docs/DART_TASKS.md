# Пошаговое руководство для LLM: Создание приложения на Dart

## Инструкции по использованию этого документа

1. Выполняйте задачи **последовательно**, одну за другой
2. Не переходите к следующей задаче, пока не завершена предыдущая
3. После завершения каждой задачи подтвердите, что она выполнена
4. Если возникает ошибка, остановитесь и попросите пользователя о помощи
5. Сохраняйте код в соответствующих файлах и папках
6. Не создавайте "лишний" код - только то, что указано в задаче

---

## Фаза 1: Подготовка окружения

### Задача 1.1: Создание базовой структуры проекта

**Цель:** Создать структуру папок для Dart-проекта

**Шаги:**
1. Создайте папку `goszakupki_dart` (или используйте существующую)
2. Внутри создайте следующую структуру папок:
   ```
   lib/
     src/
       parser/
         models/
       pdf/
       telegram/
       api/
       utils/
   bin/
   generated/
   images/
   data/
   ```

**Критерий завершения:** Все папки созданы, структура соответствует вышеуказанной.

---

## Фаза 2: Инициализация проекта

### Задача 2.1: Инициализация Dart-проекта

**Цель:** Создать базовые файлы конфигурации

**Шаги:**
1. Создайте файл `pubspec.yaml` в корне проекта
2. Добавьте следующие зависимости:
   - shelf (для сервера)
   - shelf_router (для маршрутизации)
   - http (для HTTP-запросов)
   - json_annotation (для работы с JSON)
   - build_runner (для генерации кода)
   - html (для парсинга HTML)
   - intl (для форматирования чисел и дат)
3. Создайте файл `.gitignore` и добавьте:
   - `.dart_tool/`
   - `build/`
   - `*.g.dart`
   - `.env`
4. Создайте файл `.env.example` с заглушками для переменных окружения

**Критерий завершения:** `pubspec.yaml` создан, зависимости добавлены, `.gitignore` и `.env.example` существуют.

---

## Фаза 3: Модели данных

### Задача 3.1: Создание модели CustomerData

**Цель:** Создать модель данных для информации о компании

**Шаги:**
1. Создайте файл `lib/src/parser/models/customer_data.dart`
2. Добавьте класс `CustomerData` с полями:
   - `fullName: String`
   - `shortName: String?`
   - `unp: String`
   - `address: String?`
   - `status: String?`
   - `registrationDate: String?`
3. Используйте аннотации `@JsonSerializable()`
4. Создайте методы `fromJson` и `toJson` через json_annotation

**Критерий завершения:** Файл создан, класс существует с указанными полями, аннотации добавлены.

---

### Задача 3.2: Создание модели LotItem

**Цель:** Создать модель для позиции в лоте

**Шаги:**
1. Создайте файл `lib/src/parser/models/lot_item.dart`
2. Добавьте класс `LotItem` с полями:
   - `name: String`
   - `quantity: double`
   - `unit: String`
   - `price: double`
3. Добавьте геттер `total` (quantity * price)
4. Используйте `@JsonSerializable()`
5. Создайте методы `fromJson` и `toJson`

**Критерий завершения:** Файл создан, класс существует, геттер `total` работает корректно.

---

### Задача 3.3: Создание модели ProcurementData

**Цель:** Создать модель для данных закупки

**Шаги:**
1. Создайте файл `lib/src/parser/models/procurement_data.dart`
2. Добавьте класс `ProcurementData` с полями:
   - `url: String`
   - `customer: CustomerData?`
   - `lotDescription: String?`
   - `lotCount: double?`
   - `lotUnit: String?`
   - `hasSecondLot: bool`
   - `lotDescription2: String?`
   - `lotCount2: double?`
   - `lotUnit2: String?`
   - `place: String?`
   - `payment: String?`
   - `endDate: String?`
   - `date: String`
   - `pageType: PageType`
3. Создайте enum `PageType` со значениями: marketing, tender, request, contract, singleSource
4. Используйте `@JsonSerializable()`
5. Создайте методы `fromJson` и `toJson`

**Критерий завершения:** Файл создан, класс и enum существуют, все поля определены.

---

## Фаза 4: API-клиент для налоговой

### Задача 4.1: Создание базового API-клиента

**Цель:** Создать класс для запросов к налоговому API

**Шаги:**
1. Создайте файл `lib/src/utils/unp_api_client.dart`
2. Создайте класс `UnpApiClient` с полями:
   - `baseUrl: String` (const: https://grp.nalog.gov.by/api/nice/public/api/v1)
   - `maxAttempts: int` (по умолчанию: 5)
   - `timeout: Duration` (по умолчанию: 20 секунд)
3. Создайте конструктор
4. Не создавайте методы пока

**Критерий завершения:** Класс создан с указанными полями и конструктором.

---

### Задача 4.2: Добавление метода getCompanyData

**Цель:** Реализовать получение данных компании по УНП

**Шаги:**
1. В файле `lib/src/utils/unp_api_client.dart` добавьте метод:
   ```dart
   Future<CustomerData?> getCompanyData(String unp) async {
     // Логика будет добавлена в следующей задаче
     return null;
   }
   ```
2. Метод должен принимать `unp` (String) и возвращать `Future<CustomerData?>`

**Критерий завершения:** Метод объявлен, компилируется, возвращает null.

---

### Задача 4.3: Реализация логики retry для getCompanyData

**Цель:** Добавить retry-логику с экспоненциальной задержкой

**Шаги:**
1. В методе `getCompanyData` создайте цикл for от 0 до `maxAttempts`
2. Внутри цикла:
   - Создайте URL: `$baseUrl/unp/$unp`
   - Попытайтесь выполнить GET-запрос с таймаутом
   - Если статус 200: парсите JSON и возвращайте CustomerData
   - Если статус 404: возвращайте null
   - Если транзиентная ошибка (429 или >=500): ждите и продолжайте цикл
   - При любой другой ошибке: повторите цикл (если попытки остались)
3. Добавьте метод `_isTransientError(int statusCode)` для проверки
4. Добавьте метод `_delayBeforeRetry(int attempt)` для задержки
   - Используйте экспоненциальную задержку: baseDelay * (2 ^ attempt)
   - Добавьте случайный джиттер (0-1000 мс)
5. После цикла возвращайте null

**Критерий завершения:** Метод выполняет retry с экспоненциальной задержкой, обрабатывает все коды ответов.

---

## Фаза 5: Генерация PDF

### Задача 5.1: Создание класса PdfGenerator

**Цель:** Создать базовый класс для генерации PDF

**Шаги:**
1. Создайте файл `lib/src/pdf/pdf_generator.dart`
2. Создайте класс `PdfGenerator` с полями:
   - `templatePath: String` (путь к файлу calculator-template.html)
   - `generatedDir: String` (путь к папке generated/)
3. Создайте конструктор
4. Не создавайте методы пока

**Критерий завершения:** Класс создан, поля определены, конструктор существует.

---

### Задача 5.2: Создание структуры данных для шаблона

**Цель:** Создать класс TemplateData с полями для Handlebars-шаблона

**Шаги:**
1. Создайте файл `lib/src/pdf/models/template_data.dart`
2. Создайте класс `TemplateData` с полями:
   - `COMPANY_NAME: String`
   - `UNP: String`
   - `ADDRESS: String`
   - `DATE: String`
   - `PLACE: String`
   - `PAYMENT: String`
   - `END_DATE: String`
   - `FREE_DESCRIPTION: String?`
   - `lot_1_items: List<LotItem>?`
   - `lot_2_items: List<LotItem>?`
   - `has_first_lot: bool`
   - `has_second_lot: bool`
   - `total_amount: double?`
   - `total_amount_2: double?`
   - `total_summary_amount: double?`
   - `LOGO_PATH: String`
   - `PECHAT_PATH: String`
3. Создайте конструктор с именованными параметрами

**Критерий завершения:** Класс создан, все поля определены, конструктор работает.

---

### Задача 5.3: Создание метода formatNumber

**Цель:** Создать функцию для форматирования чисел в белорусском формате

**Шаги:**
1. Создайте файл `lib/src/utils/formatter.dart`
2. Создайте функцию `formatNumber(double value)` которая:
   - Форматирует число с разделителями пробелов
   - Использует локаль 'ru-RU'
   - Показывает 2 знака после запятой
   - Пример: 10000.50 → "10 000,50"
3. Используйте пакет `intl`

**Критерий завершения:** Функция работает, форматирование соответствует требованиям.

---

### Задача 5.4: Создание метода generatePDF в PdfGenerator

**Цель:** Реализовать основную логику генерации PDF

**Шаги:**
1. В классе `PdfGenerator` добавьте метод:
   ```dart
   Future<Map<String, dynamic>> generatePDF(TemplateData data) async {
     // Верните карту с fileName и filePath
   }
   ```
2. Метод должен:
   - Подготовить данные для шаблона (все числовые поля отформатировать)
   - Сгенерировать имя файла в формате: `KP_{companyName}_{YYYYMMDD}_{HHmmss}.pdf`
   - Временно верните данные без реальной генерации PDF (будет добавлено позже)
   - Вернуть карту: `{'fileName': fileName, 'filePath': filePath}`

**Критерий завершения:** Метод существует, генерирует корректное имя файла, возвращает карту.

---

## Фаза 6: Telegram-интеграция

### Задача 6.1: Создание класса TelegramSender

**Цель:** Создать базовый класс для отправки в Telegram

**Шаги:**
1. Создайте файл `lib/src/telegram/telegram_sender.dart`
2. Создайте класс `TelegramSender` с полями:
   - `token: String`
   - `defaultChatId: String?`
3. Создайте конструктор
4. Не создавайте методы пока

**Критерий завершения:** Класс создан, поля определены, конструктор существует.

---

### Задача 6.2: Добавление метода checkAvailability

**Цель:** Реализовать проверку доступности Telegram бота

**Шаги:**
1. В классе `TelegramSender` добавьте метод:
   ```dart
   Future<Map<String, dynamic>> checkAvailability() async {
     // Верните карту с полем available (bool) и message (String)
   }
   ```
2. Метод должен:
   - Попытаться выполнить запрос к API Telegram: `https://api.telegram.org/bot{token}/getMe`
   - Если запрос успешен: вернуть `{available: true, message: 'Telegram бот доступен'}`
   - Если ошибка: вернуть `{available: false, message: error.message}`

**Критерий завершения:** Метод существует, проверяет доступность бота, возвращает корректную карту.

---

## Фаза 7: Сервер

### Задача 7.1: Создание базового сервера

**Цель:** Создать базовую структуру HTTP-сервера

**Шаги:**
1. Создайте файл `bin/server.dart`
2. Импортируйте `shelf` и `shelf_router`
3. Создайте функцию `main()`:
   - Инициализируйте Router
   - Добавьте маршрут GET `/health` который возвращает JSON со статусом
   - Запустите сервер на порту 3001
4. Создайте файл `lib/src/api/server.dart` с классом `Server`

**Критерий завершения:** Сервер запускается, endpoint `/health` отвечает.

---

### Задача 7.2: Добавление endpoint GET /api/company/:unp

**Цель:** Создать endpoint для получения данных компании

**Шаги:**
1. В `lib/src/api/server.dart` добавьте метод:
   ```dart
   Response getCompany(Request request) {
     // Извлеките UNP из URL параметра
     // Верните JSON с данными компании
   }
   ```
2. Метод должен:
   - Извлечь UNP из параметров запроса
   - Использовать `UnpApiClient` для получения данных
   - Вернуть JSON: `{success: bool, data: CustomerData?}`

**Критерий завершения:** Endpoint создан, возвращает данные компании в корректном формате.

---

### Задача 7.3: Добавление endpoint GET /telegram-status

**Цель:** Создать endpoint для проверки статуса Telegram

**Шаги:**
1. В `lib/src/api/server.dart` добавьте метод:
   ```dart
   Response getTelegramStatus(Request request) {
     // Верните статус Telegram бота
   }
   ```
2. Метод должен:
   - Использовать `TelegramSender.checkAvailability()`
   - Вернуть JSON с результатом проверки

**Критерий завершения:** Endpoint создан, возвращает корректный статус Telegram.

---

## Фаза 8: Тестирование

### Задача 8.1: Создание тестового файла

**Цель:** Создать базовый тестовый файл

**Шаги:**
1. Создайте папку `test/`
2. Создайте файл `test/api_client_test.dart`
3. Добавьте простой тест:
   ```dart
   void main() {
     print('Test running...');
   }
   ```

**Критерий завершения:** Тестовый файл создан, запуск не вызывает ошибок.

---

### Задача 8.2: Тест API-клиента

**Цель:** Добавить тест для API-клиента

**Шаги:**
1. В файле `test/api_client_test.dart` создайте тест:
   ```dart
   void main() {
     test('Test UnpApiClient initialization', () {
       final client = UnpApiClient();
       expect(client.baseUrl, isNotNull);
       expect(client.maxAttempts, 5);
     });
   }
   ```
2. Запустите тест командой `dart test`

**Критерий завершения:** Тест создан, проходит успешно.

---

## Фаза 9: Документация

### Задача 9.1: Создание README.md

**Цель:** Создать README файл с инструкциями по запуску

**Шаги:**
1. Создайте файл `README.md` в корне проекта
2. Добавьте разделы:
   - Название проекта
   - Описание
   - Требования (Dart SDK)
   - Установка зависимостей (`dart pub get`)
   - Запуск проекта (`dart run bin/server.dart`)
   - API Endpoints (список созданных endpoints)

**Критерий завершения:** README создан, содержит все указанные разделы.

---

## Критерии завершения проекта

Проект считается завершенным, когда:
- ✅ Все задачи выполнены
- ✅ Сервер запускается без ошибок
- ✅ API endpoints отвечают корректно
- ✅ Тесты проходят
- ✅ README.md содержит инструкции

---

## Важные примечания для LLM

1. **НЕ создавайте** дополнительный код вне задач
2. **НЕ добавляйте** функции, которые не указаны явно
3. **НЕ оптимизируйте** код без запроса
4. **НЕ создавайте** тесты для всего сразу (только там, где указано)
5. **ПОДТВЕРЖДАЙТЕ** завершение каждой задачи перед продолжением
6. **ПРОВЕРЯЙТЕ** компиляцию после каждого значительного изменения

Если вы не знаете, как выполнить конкретную задачу, **остановитесь и спросите пользователя**, не делайте предположений.